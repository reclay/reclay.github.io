<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[从use strict看JS（二）：函数传参模式与arguments]]></title>
      <url>%2Fsee-js-from-use-strict-arguments%2F</url>
      <content type="text"><![CDATA[use strict 的 arguments上一篇说到，use strict对arguments做了以下限定 arguments。不允许对arguments赋值。禁止使用arguments.callee。arguments不再追踪参数的变化 这是为什么呢？如果你明白下面两个例子就不用看这篇文章了~ arguments传的是“值”function notChangeName(obj){ obj=&quot;change&quot;; } function changeName(obj){ obj.name=&quot;change&quot;; } var dog={ name:&quot;dog&quot; }; notChangeName(dog); //输出Object {name: &quot;dog&quot;}，没改变 console.log(dog); changeName(dog); //输出Object {name: &quot;change&quot;}，改了 console.log(dog); //经典例子,JavaScript高级程序设计的例子 function setName(obj){ obj.name=&quot;doge&quot;; obj=new Object(); obj.name=&quot;cat&quot;; } var person={}; setName(person); //doge console.log(person.name); 严格模式下arguments会保持对同一“值”的引用function notChangeName(name){ &quot;use strict&quot;; name=&quot;cat&quot;; // 严格模式输出dog，非严格输出cat console.log(arguments[0]); } function changeName(obj){ &quot;use strict&quot;; obj.name=&quot;cat&quot;; // 输出cat console.log(arguments[0].name); } notChangeName(&quot;dog&quot;); changeName({name:&quot;dog&quot;}); function dog(){ // &quot;use strict&quot;; //严格模式SyntaxError，非严格输出&quot;a&quot; arguments=&quot;a&quot;; console.log(arguments); } dog(); arguments &amp; js的变量、值、类型js的变量、值、类型 js一个变量对应一个值，一个值对应一种类型；而一种类型对应多个值，一个值对应多个变量。字符串的值不能改变，但能让变量指向不同的值 举两个栗子：no1. var dog={ } var cat=dog; dog.name=&quot;doge&quot;; var third={ name:&quot;the third man&quot; } // 输出doge console.log(cat.name); 上述例子中，dog和cat是不同的变量，但指向同一个值，所以dog改变会反应到cat上。third是另外一个变量，指向不同的值，而这两个值有相同的类型。如下图no2. var str=&quot;doge&quot;; // 输出o console.log(str[1]); str[1]=&quot;c&quot;; // 输出o，字符串的值不能改变 console.log(str[1]); str=&quot;cat&quot;; // 输出c，变量指向了不同的值 console.log(str[0]); arguments传的是值所以，在前面的例子中，notChangeName函数内部将变量obj指向不同的值，外部的dog指向同一个值且值未发生变化。因而不能改变dog的name。changeName函数中，obj和dog指向同一个值，更改obj的name就等于更改了dog的name。JavaScript高级程序设计的例子同理。如下： function notChangeName(obj){ obj=&quot;change&quot;; } function changeName(obj){ obj.name=&quot;change&quot;; } var dog={ name:&quot;dog&quot; }; notChangeName(dog); //输出Object {name: &quot;dog&quot;}，没改变 console.log(dog); changeName(dog); //输出Object {name: &quot;change&quot;}，改了 console.log(dog); //经典例子,JavaScript高级程序设计的例子 function setName(obj){ obj.name=&quot;doge&quot;; obj=new Object(); obj.name=&quot;cat&quot;; } var person={}; setName(person); //doge console.log(person.name); use strict下的arguments会保持对“值”的引用，因而arguments变量是不能被重新赋值的，如果强制赋值呢？比如arguments=”a”，那就强制报错，没得商量。也是因为保持对“值”的引用，arguments不再追踪参数的变化，但如果参数是obj且改变的是“值”，而不是重新赋值，那就不一样了。如下： function notChangeName(name){ &quot;use strict&quot;; name=&quot;cat&quot;; // 严格模式输出dog，非严格输出cat console.log(arguments[0]); } function changeName(obj){ &quot;use strict&quot;; obj.name=&quot;cat&quot;; // 输出cat console.log(arguments[0].name); } notChangeName(&quot;dog&quot;); changeName({name:&quot;dog&quot;}); function dog(){ // &quot;use strict&quot;; //严格模式SyntaxError，非严格输出&quot;a&quot; arguments=&quot;a&quot;; console.log(arguments); } dog(); 面试会考：arguments不是数组这就是一个点而已，arguments不是数组，是个类数组对象，没有数组的push、pop、map那些方法，那如何把它变为数组呢？循环遍历一遍也是可以的，arguments有长度，但有更简单的方法，如下： function argToArr(index){ var newArg=Array.prototype.slice.apply(arguments); newArg.push(2); } argToArr(1); 为何不直接 arguments=Array.prototype.slice.apply(arguments); 因为现在很多都用use strict了，这个会报错，还不知道为何会报错的再看一遍文章哈，自觉点 最后谈谈arguments.callee这个用来干啥呢，它能在函数内部调用自己，常用来解耦和。比如写个斐波那契数列函数 function fib(n){ if(n===1||n===2){ return 1; } return fib(n-1)+fib(n-2); } 这个问题在哪呢，耦合性太强，改了外层的fib，内部函数名称也得改。可以用arguments.callee改进 function fibArg(n){ if(n===1||n===2){ return 1; } return arguments.callee(n-1)+arguments.callee(n-2); } 问题是这个在严格模式下不能运行。不绕了，来个终极方法 var fib=(function f(n){ &quot;use strict&quot;; if(n===1||n===2){ return 1; } return f(n-1)+f(n-2); }) 这种模式之后还会涉及，跟立即执行函数类似，jQuery这些也用了，以后再聊~ 等等好像没谈为何要这样限定arguments！ 夜已深，就不继续悟道了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从use strict看JS（一）：this与箭头函数]]></title>
      <url>%2Fsee-js-from-use-strict-this-and-arrow-function%2F</url>
      <content type="text"><![CDATA[系列一日，见“use strict”，冥想许久…… 这是这个系列第一篇文章，后几篇还没写出来。 use strictuse strict指js的严格模式，还没了解的看这里：Javascript 严格模式详解 use strict有3点比较重要 函数调用this为undefined arguments。不允许对arguments赋值。禁止使用arguments.callee。arguments不再追踪参数的变化 不用var声明不会提升成全局变量，而是报错 use strict还有一些常人不易写错的，不纳入写作范围： 对象不能有重名的属性,函数不能有重名的参数 规定保留字。class, implements 回归正题，什么是函数调用？为何严格模式函数调用要将this指向undefined？ this调用的四种模式首先牢记：js function有四种方式调用，每一种的this都不同。 方法调用当函数被保存为对象的属性时，我们称这个函数为方法。方法调用的this就绑定到该对象 var dog={ name:&quot;doge&quot;, sayName:function(){ console.log(this.name); } } //输出doge，this绑定到了dog dog.sayName(); 函数调用声明一个function然后调用。非严格模式this指向window，严格模式是undefined function sayName(){ console.log(this); } function sayNameStrict(){ &quot;use strict&quot;; console.log(this); } //指向window sayName(); //开启严格模式，指向undefined sayNameStrict(); 构造函数调用这在对象、对象继承用的比较多，通过new来使用，this指向new出来的新对象。后面会有文章讲解new如何实现，到时候就会很清楚。 function Dog(name){ this.name=name; } var dog=new Dog(&quot;doge&quot;); //this指向dog console.log(dog.name); apply &amp; call &amp; bind这类就是改变this，apply和call是很重要的，所以许多面试都会问，之后的文章我们会看到它们的强大作用。 问题：当对象的方法返回了函数？那就是函数调用了。这是js的一个设计错误，this应该绑定到外部函数的this变量，这个错误即是“函数调用”this绑定的错误。严格模式规定，this不指向window了，但并没有解决这个问题，于是箭头函数来了。 var dog={ name:&quot;doge&quot;, sayName:function(){ return function(){ console.log(this); } } } // 此时是函数调用，this指向window dog.sayName()(); 箭头函数对this的改变箭头函数怎么解决这个问题呢？其实用了闭包，改成下面这样，babel啥的也是这样做的。 var dog = { name: &quot;doge&quot;, sayName: function sayName() { var _this = this; return function () { console.log(_this); }; } }; 那如果嵌套了多层箭头函数？对闭包来说是一样的 var dog={ name:&quot;doge&quot;, sayName:function(){ return ()=&gt;{ return ()=&gt;{ console.log(this); } } } } 相当于 var dog = { name: &quot;doge&quot;, sayName: function sayName() { var _this = this; return function () { return function () { console.log(_this); }; }; } }; 那如果函数的属性就是箭头函数？没有这样用的！你会拿到window var dog={ name:&quot;doge&quot;, sayName:()=&gt;{ console.log(this); } } // this指向window，因为箭头函数 dog.sayName(); the good parts 这是一本书，文末有链接。 the good parts说过：js语言有些地方设计得不好，于是后来的标准不断地补坑。the good parts又说过：js 函数调用this绑定到window是一个设计错误 等等，严格模式函数调用this为何指向undefined？？ 首先，不该指向window，所以换一个。 其次，指向undefined有一个好处，构造函数一般不要直接运行，那要是强行运行呢？this指向window会给window添加许多属性，有扰乱命名空间之嫌，指向undefined之后，你强行运行我就强行报错！ function Dog(name){ this.name=name; } //会给window增加name属性，改成严格模式就会TypeError Dog(&quot;doge&quot;); 当然，use strict不能解决所有问题，所以有了箭头函数 参考Javascript 严格模式详解the good parts]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[about-es]]></title>
      <url>%2Fabout-es%2F</url>
      <content type="text"><![CDATA[常说的ES6是啥？js在1995 年Netscape 首发，1996 年转化成标准，即ECMAScript，简称ES。 2009年12月，ES5发布。2015 年，负责制定 ECMAScript 规范草案的委员会决定一年定一次标准，哈哈~ ECMAScript第六版即ES6在2015.06发布，又称ES2015，照这样说，ES2016应该是ES7，而今年2017就应该是ES8。有道理！ 但实际中大家常说的是ES6，因为ES7改变并不大，而ES6相比于ES5改动就大了。 详见ECMAScript 6简介]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown]]></title>
      <url>%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[链接和图片[clay](https://reclay.github.io) ![clay](https://reclay.github.io/avator.jpg) 标题# 一级标题 ## 二级标题 列表无序- 文本1 - 文本2 有序1. 文本1 2. 文本2 引用&gt; 引用1 代码四个空格 表格| 标题1 | 标题2 | 标题3 | |------ | :-----: | ----: | | 默认左对齐 | 居中 | 右对齐 | | 占位占位占位占位 | 占位占位占位占位占位 | 占位占位占位占位占位 | 效果如下： 标题1 标题2 标题3 默认左对齐 居中 右对齐 占位占位占位占位 占位占位占位占位占位 占位占位占位占位占位]]></content>
    </entry>

    
  
  
</search>
