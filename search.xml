<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[css 命名：BEM, scoped css, css modules 与 css-in-js]]></title>
      <url>%2Forganize-css%2F</url>
      <content type="text"><![CDATA[css 作用域是全局的，项目越来越大，人越来越多，命名慢慢成为问题，以下是几种解决命名问题的方案 一. BEM以 .block__element–modifier 形式命名，命名有含义，block 可视为模块，有一定作用域含义 实例.dropdown-menu__item–active 二. scoped css参考：https://vue-loader.vuejs.org/zh/guide/scoped-css.html 目标：当前组件样式不会影响其它组件 给组件的 dom 节点添加惟一属性，并转换 style 标签中的 css 匹配该属性，使得 css 作用域有限 实例123456789&lt;style scoped&gt;.example &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class="example"&gt;hi&lt;/div&gt;&lt;/template&gt; 转换结果：123456789&lt;style&gt;.example[data-v-f3f3eg9] &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class="example" data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt; 三. css modules参考：https://vue-loader.vuejs.org/zh/guide/css-modules.html 将 css 的选择器转换成惟一的字符串，运用到 dom。是在用算法命名，记录了人的命名到算法命名的 map 表 实例12345678910&lt;style module&gt;.red &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;p :class="$style.red"&gt; This should be red &lt;/p&gt;&lt;/template&gt; 转换结果：12345678910&lt;style module&gt;._1yZGjg0pYkMbaHPr4wT6P__1 &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;p class="_1yZGjg0pYkMbaHPr4wT6P__1"&gt; This should be red &lt;/p&gt;&lt;/template&gt; 四. css-in-js参考：https://github.com/styled-components/vue-styled-components 将 css 内容用惟一的选择器表示。同 css modules，用算法命名。将 css 视为 js 的字符串，赋予 css 更多能力 实例1234567891011121314&lt;template&gt; &lt;css-in-js&gt;&lt;/css-in-js&gt;&lt;/template&gt;&lt;script&gt; import styled from 'vue-styled-components'; export default &#123; components: &#123; cssInJs: styled.div ` color: red; ` &#125; &#125;&lt;/script&gt; 转换结果：12345678&lt;template&gt; &lt;div class="gXTzCp"&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.gXTzCp &#123; color: red;&#125;&lt;/style&gt; 五. 总结 BEM 让命名有规律、有含义，block 可视为模块，有一定作用域含义 scoped css 限定 css 作用域，无关命名。无法适配多套主题 css modules 使用算法命名，没有了命名冲突，也限定了 css 作用域。无法适配多套主题 css-in-js 使用算法命名，拥有 css modules 的优势。同时将 css 视为 js 的字符串，赋予 css 更多能力]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RN 踩坑：杂记]]></title>
      <url>%2Freact-native-pits%2F</url>
      <content type="text"><![CDATA[之前遇到的坑很多已经忘记了，现在遇到再慢慢记录吧 一些环境上的配置：https://segmentfault.com/a/1190000006927476 android webView injectedJavaScript 不支持注释 android webView uri 引入需放到 file:///android_asset source={html: ‘’} 的写法，字符串会被 decode，导致一些代码如取余 %12 decode 成其它代码，运行失败，可先 encode source={html: ‘’} 的写法，如有正则，/\\/ 会变成 /\/ 导致匹配结果失败，用 String.raw 解决 用 String.raw，字符串 \2 报错，升级 babel 到 7 可解决 内容区域高度：https://juejin.im/post/5c03b0076fb9a049e063145e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RN 踩坑：内容区域高度]]></title>
      <url>%2Freact-native-height%2F</url>
      <content type="text"><![CDATA[万万没想到，魅族有个 Smart bar 以下内容要是不小心搞错了还请好心人士指正 DimensionsDimensions 获取的是设备屏幕分辨率对应的宽高，包含了 status bar 以及其它 bar. iosios 比较简单，就一个 statusBar，iphoneX 是一类，其它的是一类，使用 paddingTop 可抵消 statusBar，项目使用 native-base 的 header，设置如下：12paddingTop: platform === "ios" ? (variables.isIphoneX ? 39 : 15) : 0height: platform === "ios" ? (isIphoneX ? 88 : 64) : 56 androidandroid 有三种 bar：Soft menu, Status bar, Smart bar，其中，Smart bar 为魅族特有。在使用内容区域高度时需要考虑以上三种 bar。当然，工具已经有人做好了：https://github.com/Sunhat/react-native-extra-dimensions-android flex 大法如果不想计算内容区域高度，通通用 flex 也是可以的 多说一句第一个万万没想到应该是小米手机开发者模式竟然要插 sim 卡，要插 sim 卡…… 耿耿于怀 n 年]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 源码(一)：响应式原理]]></title>
      <url>%2Fvue-source-code%2F</url>
      <content type="text"><![CDATA[相关文章网上已经很多了，趁 3.0 没出跟风打个卡 前言本文只做简单介绍，结合代码食用更佳：github/vue-learn-source-code效果预览：github pages Object.definePropertydefineProperty 让我们可以劫持某个属性的 getter 和 setter，举个例子： 1234567891011121314var person = &#123; firstName: 'meimei', lastName: 'han'&#125;;Object.defineProperty(person, 'fullName', &#123; get() &#123; return this.lastName + ' ' + this.firstName; &#125;, set(val) &#123; let arr = val.split(' '); this.lastName = arr[0]; this.firstName = arr[1]; &#125;&#125;); 劫持 fullName 后，改变 firstName 或 lastName 会更新 fullName，反之亦然 目标本文的目标是仿造 vue 实现改变数据后更新 dom，让以下代码能够 work：1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;p&gt;firstName: &#123;&#123;firstName&#125;&#125;&lt;/p&gt; &lt;p&gt;lastName: &#123;&#123;lastName&#125;&#125;&lt;/p&gt; &lt;p&gt;fullName: &#123;&#123;fullName&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="./vue.js"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data() &#123; return &#123; firstName: 'meimei', lastName: 'han' &#125;; &#125;, computed: &#123; fullName: &#123; get: function() &#123; return this.lastName + ' ' + this.firstName; &#125;, set: function(val) &#123; let arr = val.split(' '); this.lastName = arr[0]; this.firstName = arr[1]; &#125; &#125; &#125; &#125;);&lt;/script&gt; 观察者模式我们要做的是数据变化后去更新 dom，观察者模式很适合数据只需要收集依赖，当数据变化通知依赖更新即可，先建一个类描述这件事： 12345678910111213class Dep &#123; constructor() &#123; this.subs=[] &#125; addSub(item) &#123; this.subs.push(item); &#125; notify() &#123; this.subs.forEach(item =&gt; &#123; item.update(); &#125;); &#125;&#125; 再细想一下，dom 依赖 data，则在获取 dom 的过程中需要用到 data 的 get，在 data get 时收集依赖即可，set data 时执行 dom 的 updateget data 时需要记录依赖 data 的数据，给 class Dep 增加一个属性 target 作为记录工具，结合 defineProperty 实现如下： 12345678910111213141516171819Dep.target = undefined;function defineReactive(obj, key) &#123; let dep = new Dep(); let val = obj[key]; Object.defineProperty(obj, key, &#123; get: function() &#123; if (Dep.target) &#123; // get 中收集依赖 dep.addSub(Dep.target); &#125; return val; &#125;, set: function(value) &#123; val = value; // set 中触发更新 dep.notify(); &#125; &#125;)&#125; 工具已备齐，接下来就是遍历 data 的属性，用 defineReactive 走一遍 data, computed, dom 的依赖关系解析 dom 会用到 data 和 computed，computed 的 get 会用到 data 遍历 data 123456789function initData(vm) &#123; let data = vm.$options.data; data = typeof data === 'function' ? data() : data; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key); &#125;); // 把 data 的属性代理到 vm 实例 proxy(data, vm);&#125; 遍历 computed 12345678910111213141516function initComputed(vm) &#123; let computed = vm.$options.computed; let defaultSetter = function(key) &#123; console.error(this, ' has no setter for ', key) &#125; Object.keys(computed).forEach(key =&gt; &#123; let getter = typeof computed[key] === 'function' ? computed[key] : computed[key].get; let setter = typeof computed[key] === 'function' ? defaultSetter.bind(computed) : computed[key].set; Object.defineProperty(computed, key, &#123; get: getter.bind(vm), set: setter.bind(vm) &#125;) &#125;) // 把 computed 的属性代理到 vm 实例 proxy(computed, vm);&#125; 解析 dom 1234567891011121314151617181920212223242526function mount(vm) &#123; let update = compile(vm); let watcher = new Watcher(update); // 把 target 标为 dom Dep.target = watcher; update(); Dep.target = undefined;&#125;function compile(vm) &#123; let el = vm.$options.el; el = document.querySelector(el); vm.$el = el; let innerHTML = el.innerHTML; let getter = function() &#123; return innerHTML.replace(/&#123;&#123;(.*?)&#125;&#125;/g, function() &#123; // 这里用到了 data computed 的 get，收集了依赖 return vm[arguments[1]] &#125;); &#125;; let update = function() &#123; let iHTML = getter(); el.innerHTML = iHTML; &#125; return update;&#125; 多说一句在收集依赖时，我们给 Dep 这个 class 增加一个属性 target，在 vue 中还结合了 targetStack。这种收集方式稍微管理不慎就可能存在 bug，在另一篇文章有提过：熟悉 Vue ？你能解释这个死循环吗？。为自己的填坑喝彩~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 vue + d3 画一棵树]]></title>
      <url>%2Fvue-d3%2F</url>
      <content type="text"><![CDATA[结果预览github pages vue 和 d3 的角色画图可分为两步： 元素坐标计算 数据绑定 坐标计算只需要一些 api，本文使用 d3。数据绑定既可以借助 d3，也可以使用 vue。d3 通过操作 dom 实现，有点像 jQuery，d3 针对数据和 dom 的状态提出了三个概念：Update、Enter、Exit，感兴趣的可以看官网。本文使用 vue 做数据绑定 总结：使用 d3 提供的 api 计算元素坐标，使用 vue 进行数据绑定 坐标计算一棵树由节点和连接构成，只需要计算出这两种元素的坐标即可 画一棵树常见的有两种数据结构，一种是嵌套的，一种是扁平的。如下： 12345678910111213141516171819202122232425262728293031// 嵌套的var treeData = &#123; name: '中国', children: [&#123; name: '北京', children: [&#123; name: '海淀' &#125;, &#123; name: '朝阳' &#125;] &#125;, &#123; name: '上海' &#125;]&#125;;// 扁平的var flattenData = [&#123; name: '中国', parent: ''&#125;, &#123; name: '北京', parent: '中国'&#125;, &#123; name: '上海', parent: '中国'&#125;, &#123; name: '海淀', parent: '北京'&#125;, &#123; name: '朝阳', parent: '北京'&#125;] 对于嵌套的数据，使用 d3.hierarchy() 计算坐标，对于扁平的，使用 d3.stratify()。得到的结构如下(列举根节点)： 123456789101112var hierarchyNode = &#123; depth: 0 height: 2 parent: null x: 60 y: 0, data: &#123; name: "中国"， children: [] &#125;, children: []&#125;; 得到根节点后使用 descendants() 获取所有节点信息，links() 获取所有连接信息。节点的结构如上述，连接结构如下： 1234var link = &#123; source: Node, target: Node&#125; 至此，已获取到所有元素的坐标 数据绑定使用 svg 树的节点就是 rect + text，如下： 12345&lt;g :transform="rootTransform"&gt; &lt;rect :width="nodeWidth" :height="nodeHeight" :fill="nodeFill"&gt;&lt;/rect&gt; &lt;text :fill="nodeTextColor" text-anchor="middle" dominant-baseline="middle" :y="nodeHeight / 2" :x="nodeWidth / 2"&gt;&#123;&#123;node.data.name&#125;&#125;&lt;/text&gt;&lt;/g&gt; 连接就是 path，如下： 123&lt;g&gt; &lt;path :d="getLinkPath(link)" :stroke="linkStroke" fill="none" :stroke-width="linkStrokeWidth"&gt;&lt;/path&gt;&lt;/g&gt; code talk is cheap show me the code github/vue-d3-tree-example]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[熟悉 Vue ？你能解释这个死循环吗？]]></title>
      <url>%2Fvue-loop%2F</url>
      <content type="text"><![CDATA[最新填坑：Vue 源码(一)：响应式原理 ====== 更新线 =====评论区有了相关讨论，贴更详细一点的解释出来====== 更新线 =====循环出现的条件： key=&quot;Math.random()&quot; 子组件在 created 中输出计算属性并改变 data 与 Vue watcher 的添加机制有关，初步认为是 Vue 的小 bug，dep 对象的 targetStack 管理不当导致 ================== 分割线 =============== 把下面的代码拷到你的 html 文件，在浏览器打开你会看到控制台报了死循环的错，知道为什么吗？ 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;div id="app"&gt; &lt;child-comp v-for="i in [1]" :key="Math.random()" :sub-prop="parentData"&gt;&lt;/child-comp&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.16/vue.js"&gt;&lt;/script&gt; Vue.component('child-comp', &#123; props: &#123; subProp: &#123;&#125; &#125;, data() &#123; return &#123; subData: [] &#125;; &#125;, template: '&lt;div&gt;&lt;/div&gt;', computed: &#123; subComputed() &#123; return '222'; &#125; &#125;, created() &#123; console.log(this.subComputed); this.subData.push(1); &#125; &#125;); vm = new Vue(&#123; el: '#app', data() &#123; return &#123; parentData: 'hello world' &#125;; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 puppeteer 获取 jd 商品评论]]></title>
      <url>%2Fcrawler-puppeteer%2F</url>
      <content type="text"><![CDATA[jd 的评论是 js 渲染的，几年前尝试爬过，现在用 puppeteer 一试，清爽多了。puppeteer 是 Headless Chrome Node API，官方仓库：https://github.com/GoogleChrome/puppeteer 由于很简单，直接看代码注释 const puppeteer = require(&apos;puppeteer&apos;); const autoScroll = require(&apos;./autoScroll&apos;); const url = &apos;https://item.jd.com/4311178.html&apos;; async function crawler() { // 新开一个浏览器，headless false 方便可视化代码的操作 let browser = await puppeteer.launch({ headless: false }); // 开一个 tab 页 let page = await browser.newPage(); // 加载 url 页面 await page.goto(url, { waitUntil: &apos;networkidle2&apos; }); // 等一等 await page.waitFor(500); // 点开评论 tab await page.click(&apos;li[data-anchor=&quot;#comment&quot;]&apos;); // 滚一滚，让评论加载加载，这个方法内容继续往下看 // 不滚也可以，单纯想展示一下 page.evaluate() await autoScroll(page); // 获取评论，多数情况直接操作 dom 就可以了 // $eval 对应 document.querySelector，$$eval 对应 document.querySelectorAll，够用了 let comments = await page.$$eval(&apos;.comment-item .comment-con&apos;, els =&gt; { return els.map(item =&gt; item.innerText); }); // 输出一下评论，宣告抓到了 comments.forEach((item, index) =&gt; { console.log(`comment ${index} =======================`); console.log(item); }); // 关闭浏览器 await browser.close(); } crawler(); autoScroll 代码 async function autoScroll(page){ // page.evaluate 能获取上下文，相当于在当前页面执行 js，想干啥就干啥 await page.evaluate(() =&gt; { // 返回 promise，evaluate 会等 promise resolve return new Promise((resolve, reject) =&gt; { let totalHeight = 0; let distance = 200; let timer = setInterval(() =&gt; { let scrollHeight = document.body.scrollHeight; window.scrollBy(0, distance); totalHeight += distance; if(totalHeight &gt;= scrollHeight){ clearInterval(timer); resolve(); } }, 500); }); }); } module.exports = autoScroll;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node 执行 bat 命令：乱码、路径问题]]></title>
      <url>%2Fnode-messy-code%2F</url>
      <content type="text"><![CDATA[乱码index.js const shell = require(&apos;shelljs&apos;); shell.exec(&apos;aaa&apos;, function (code, stdout, stderr) { }); 执行 node index 出现乱码 先执行chcp 65001即可 路径在当前目录执行不能加./(powershell下执行需要加)，下面这个会报错 shell.exec(&apos;./test&apos;, function (code, stdout, stderr) { }); 这个报错似乎很友好，但和乱码同时出现就很懵了。纪念我的半个下午]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从use strict看JS（二）：函数传参模式与arguments]]></title>
      <url>%2Fsee-js-from-use-strict-arguments%2F</url>
      <content type="text"><![CDATA[系列系列列表：从use strict看JS（一）：this与箭头函数从use strict看JS（二）：函数传参模式与arguments use strict 的 arguments上一篇说到，use strict对arguments做了以下限定 arguments。不允许对arguments赋值。禁止使用arguments.callee。arguments不再追踪参数的变化 这是为什么呢？如果你明白下面两个例子就不用看这篇文章了~ arguments传的是“值”function notChangeName(obj){ obj=&quot;change&quot;; } function changeName(obj){ obj.name=&quot;change&quot;; } var dog={ name:&quot;dog&quot; }; notChangeName(dog); //输出Object {name: &quot;dog&quot;}，没改变 console.log(dog); changeName(dog); //输出Object {name: &quot;change&quot;}，改了 console.log(dog); //经典例子,JavaScript高级程序设计的例子 function setName(obj){ obj.name=&quot;doge&quot;; obj=new Object(); obj.name=&quot;cat&quot;; } var person={}; setName(person); //doge console.log(person.name); 严格模式下arguments会保持对同一“值”的引用function notChangeName(name){ &quot;use strict&quot;; name=&quot;cat&quot;; // 严格模式输出dog，非严格输出cat console.log(arguments[0]); } function changeName(obj){ &quot;use strict&quot;; obj.name=&quot;cat&quot;; // 输出cat console.log(arguments[0].name); } notChangeName(&quot;dog&quot;); changeName({name:&quot;dog&quot;}); function dog(){ // &quot;use strict&quot;; //严格模式SyntaxError，非严格输出&quot;a&quot; arguments=&quot;a&quot;; console.log(arguments); } dog(); arguments &amp; js的变量、值、类型js的变量、值、类型 js一个变量对应一个值，一个值对应一种类型；而一种类型对应多个值，一个值对应多个变量。字符串的值不能改变，但能让变量指向不同的值 举两个栗子：no1. var dog={ } var cat=dog; dog.name=&quot;doge&quot;; var third={ name:&quot;the third man&quot; } // 输出doge console.log(cat.name); 上述例子中，dog和cat是不同的变量，但指向同一个值，所以dog改变会反应到cat上。third是另外一个变量，指向不同的值，而这两个值有相同的类型。如下图no2. var str=&quot;doge&quot;; // 输出o console.log(str[1]); str[1]=&quot;c&quot;; // 输出o，字符串的值不能改变 console.log(str[1]); str=&quot;cat&quot;; // 输出c，变量指向了不同的值 console.log(str[0]); arguments传的是值所以，在前面的例子中，notChangeName函数内部将变量obj指向不同的值，外部的dog指向同一个值且值未发生变化。因而不能改变dog的name。changeName函数中，obj和dog指向同一个值，更改obj的name就等于更改了dog的name。JavaScript高级程序设计的例子同理。如下： function notChangeName(obj){ obj=&quot;change&quot;; } function changeName(obj){ obj.name=&quot;change&quot;; } var dog={ name:&quot;dog&quot; }; notChangeName(dog); //输出Object {name: &quot;dog&quot;}，没改变 console.log(dog); changeName(dog); //输出Object {name: &quot;change&quot;}，改了 console.log(dog); //经典例子,JavaScript高级程序设计的例子 function setName(obj){ obj.name=&quot;doge&quot;; obj=new Object(); obj.name=&quot;cat&quot;; } var person={}; setName(person); //doge console.log(person.name); use strict下的arguments会保持对“值”的引用，因而arguments变量是不能被重新赋值的，如果强制赋值呢？比如arguments=”a”，那就强制报错，没得商量。也是因为保持对“值”的引用，arguments不再追踪参数的变化，但如果参数是obj且改变的是“值”，而不是重新赋值，那就不一样了。如下： function notChangeName(name){ &quot;use strict&quot;; name=&quot;cat&quot;; // 严格模式输出dog，非严格输出cat console.log(arguments[0]); } function changeName(obj){ &quot;use strict&quot;; obj.name=&quot;cat&quot;; // 输出cat console.log(arguments[0].name); } notChangeName(&quot;dog&quot;); changeName({name:&quot;dog&quot;}); function dog(){ // &quot;use strict&quot;; //严格模式SyntaxError，非严格输出&quot;a&quot; arguments=&quot;a&quot;; console.log(arguments); } dog(); 面试会考：arguments不是数组这就是一个点而已，arguments不是数组，是个类数组对象，没有数组的push、pop、map那些方法，那如何把它变为数组呢？循环遍历一遍也是可以的，arguments有长度，但有更简单的方法，如下： function argToArr(index){ var newArg=Array.prototype.slice.apply(arguments); newArg.push(2); } argToArr(1); 为何不直接 arguments=Array.prototype.slice.apply(arguments); 因为现在很多都用use strict了，这个会报错，还不知道为何会报错的再看一遍文章哈，自觉点 最后谈谈arguments.callee这个用来干啥呢，它能在函数内部调用自己，常用来解耦和。比如写个斐波那契数列函数 function fib(n){ if(n===1||n===2){ return 1; } return fib(n-1)+fib(n-2); } 这个问题在哪呢，耦合性太强，改了外层的fib，内部函数名称也得改。可以用arguments.callee改进 function fibArg(n){ if(n===1||n===2){ return 1; } return arguments.callee(n-1)+arguments.callee(n-2); } 问题是这个在严格模式下不能运行。不绕了，来个终极方法 var fib=(function f(n){ &quot;use strict&quot;; if(n===1||n===2){ return 1; } return f(n-1)+f(n-2); }) 这种模式之后还会涉及，跟立即执行函数类似，jQuery这些也用了，以后再聊~ 等等好像没谈为何要这样限定arguments！ 夜已深，就不继续悟道了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从use strict看JS（一）：this与箭头函数]]></title>
      <url>%2Fsee-js-from-use-strict-this-and-arrow-function%2F</url>
      <content type="text"><![CDATA[系列一日，见“use strict”，冥想许久…… 系列列表：从use strict看JS（一）：this与箭头函数从use strict看JS（二）：函数传参模式与arguments use strictuse strict指js的严格模式，还没了解的看这里：Javascript 严格模式详解 use strict有3点比较重要 函数调用this为undefined arguments。不允许对arguments赋值。禁止使用arguments.callee。arguments不再追踪参数的变化 不用var声明不会提升成全局变量，而是报错 use strict还有一些常人不易写错的，不纳入写作范围： 对象不能有重名的属性,函数不能有重名的参数 规定保留字。class, implements 回归正题，什么是函数调用？为何严格模式函数调用要将this指向undefined？ this调用的四种模式首先牢记：js function有四种方式调用，每一种的this都不同。 方法调用当函数被保存为对象的属性时，我们称这个函数为方法。方法调用的this就绑定到该对象 var dog={ name:&quot;doge&quot;, sayName:function(){ console.log(this.name); } } //输出doge，this绑定到了dog dog.sayName(); 函数调用声明一个function然后调用。非严格模式this指向window，严格模式是undefined function sayName(){ console.log(this); } function sayNameStrict(){ &quot;use strict&quot;; console.log(this); } //指向window sayName(); //开启严格模式，指向undefined sayNameStrict(); 构造函数调用这在对象、对象继承用的比较多，通过new来使用，this指向new出来的新对象。后面会有文章讲解new如何实现，到时候就会很清楚。 function Dog(name){ this.name=name; } var dog=new Dog(&quot;doge&quot;); //this指向dog console.log(dog.name); apply &amp; call &amp; bind这类就是改变this，apply和call是很重要的，所以许多面试都会问，之后的文章我们会看到它们的强大作用。 问题：当对象的方法返回了函数？那就是函数调用了。这是js的一个设计错误，this应该绑定到外部函数的this变量，这个错误即是“函数调用”this绑定的错误。严格模式规定，this不指向window了，但并没有解决这个问题，于是箭头函数来了。 var dog={ name:&quot;doge&quot;, sayName:function(){ return function(){ console.log(this); } } } // 此时是函数调用，this指向window dog.sayName()(); 箭头函数对this的改变箭头函数怎么解决这个问题呢？其实用了闭包，改成下面这样，babel啥的也是这样做的。 var dog = { name: &quot;doge&quot;, sayName: function sayName() { var _this = this; return function () { console.log(_this); }; } }; 那如果嵌套了多层箭头函数？对闭包来说是一样的 var dog={ name:&quot;doge&quot;, sayName:function(){ return ()=&gt;{ return ()=&gt;{ console.log(this); } } } } 相当于 var dog = { name: &quot;doge&quot;, sayName: function sayName() { var _this = this; return function () { return function () { console.log(_this); }; }; } }; 那如果函数的属性就是箭头函数？没有这样用的！你会拿到window var dog={ name:&quot;doge&quot;, sayName:()=&gt;{ console.log(this); } } // this指向window，因为箭头函数 dog.sayName(); the good parts 这是一本书，文末有链接。 the good parts说过：js语言有些地方设计得不好，于是后来的标准不断地补坑。the good parts又说过：js 函数调用this绑定到window是一个设计错误 等等，严格模式函数调用this为何指向undefined？？ 首先，不该指向window，所以换一个。 其次，指向undefined有一个好处，构造函数一般不要直接运行，那要是强行运行呢？this指向window会给window添加许多属性，有扰乱命名空间之嫌，指向undefined之后，你强行运行我就强行报错！ function Dog(name){ this.name=name; } //会给window增加name属性，改成严格模式就会TypeError Dog(&quot;doge&quot;); 当然，use strict不能解决所有问题，所以有了箭头函数 参考Javascript 严格模式详解the good parts]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[about-es]]></title>
      <url>%2Fabout-es%2F</url>
      <content type="text"><![CDATA[常说的ES6是啥？js在1995 年Netscape 首发，1996 年转化成标准，即ECMAScript，简称ES。 2009年12月，ES5发布。2015 年，负责制定 ECMAScript 规范草案的委员会决定一年定一次标准，哈哈~ ECMAScript第六版即ES6在2015.06发布，又称ES2015，照这样说，ES2016应该是ES7，而今年2017就应该是ES8。有道理！ 但实际中大家常说的是ES6，因为ES7改变并不大，而ES6相比于ES5改动就大了。 详见ECMAScript 6简介]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown]]></title>
      <url>%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[链接和图片[clay](https://reclay.github.io) ![clay](https://reclay.github.io/avator.jpg) 标题# 一级标题 ## 二级标题 列表无序- 文本1 - 文本2 有序1. 文本1 2. 文本2 引用&gt; 引用1 代码四个空格 表格| 标题1 | 标题2 | 标题3 | |------ | :-----: | ----: | | 默认左对齐 | 居中 | 右对齐 | | 占位占位占位占位 | 占位占位占位占位占位 | 占位占位占位占位占位 | 效果如下： 标题1 标题2 标题3 默认左对齐 居中 右对齐 占位占位占位占位 占位占位占位占位占位 占位占位占位占位占位]]></content>
    </entry>

    
  
  
</search>
